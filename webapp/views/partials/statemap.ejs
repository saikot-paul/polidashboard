<script type="text/javascript">
    const width = 970;
    const widthOffset = 45;
    const height = 610;
    const outlineColor = "#888888";

    const tooltipContentTemplate = `
        <span class='tooltip-emoji' style='top: 1px; position: absolute; right: 3px;'>â—¥</span>
        <div class='maptip-title'>Avg. % of Audience for this Region (shown ads by this funder):</div>
        <hr style='margin-top: 0; margin-bottom: 10px'>
        <div class='maptip-content'>
            <p class='maptip-text'><span class='maptip-label'>State:</span> {stateName} <span class='maptip-label' style='color: yellow;'>&nbsp;&nbsp;{statePercentage}%</span></p>
            <p class='maptip-text'><span class='maptip-label'>Estimated Cost:</span></p>
            <p class='maptip-text'>{costRange}</p>
        </div>`;

	class Statemap {
		constructor(data, mapName, country='us') {
			this.data = data;
			this.mapName = mapName;
            this.country = country;

			this.draw();
		}

        async fetchTopoData() {
            try {
                let mapDataset = null;
                if (country === 'us') {
                    mapDataset = await d3.json("https://d3js.org/us-10m.v1.json");
                } else if (country === 'de') {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/de/de-all.topo.json");
                    mapDataset.transform.scale=[0.05, -0.063]
                    mapDataset.transform.translate=[225, 620]
                } else if (country === 'br') {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/br/br-all.topo.json");
                    mapDataset.transform.scale=[0.062, -0.063]
                    mapDataset.transform.translate=[165, 620]
                } else if (country === 'au') {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/au/au-all.topo.json");
                    mapDataset.transform.scale=[0.08, -0.06]
                    mapDataset.transform.translate=[63, 600]
                } else if (country == "es") { 
                    mapDataset = await d3.json("https://unpkg.com/es-atlas@0.5.0/es/autonomous_regions.json");
                    mapDataset.transform.scale=[0.115, -0.105]
                    mapDataset.transform.translate=[-200, 1050]
                } else if (country === "gb") {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/gb/custom/gb-countries.topo.json");
                    mapDataset.transform.scale=[0.041, -0.061]
                    mapDataset.transform.translate=[280, 610]
                } else if (country === "dk") {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/dk/dk-all.topo.json");
                    mapDataset.transform.scale=[0.074, -0.064]
                    mapDataset.transform.translate=[180, 630]
                } else {
                    mapDataset = await d3.json("https://code.highcharts.com/mapdata/countries/ca/ca-all.topo.json");
                    mapDataset.transform.scale=[0.081, -0.061]
                    mapDataset.transform.translate=[40, 610]
                }
                return mapDataset;
            } catch (error) {
                console.error("Error fetching map data:", error);
                throw error;
            }
        }

        draw() {  
            let _d = this.data
            
            const customColorInterpolator = t => {
                var _interpolateColor = function(color1, color2, factor) {
                    if (arguments.length < 3) { factor = 0.5; }
                    var result = color1.slice();
                    for (var i=0;i<3;i++) {
                        result[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));
                    }
                    return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
                };

                t = Math.min(1, Math.max(0, t));
                if (t === 0) {
                    return `rgb(255, 255, 255)`;
                }

                const firstColor = [255, 255, 255];
                const secondColor = [0, 110, 189];
                const logT = Math.log10(90 * t + 10) - 1;
                return _interpolateColor(firstColor, secondColor, logT)
            };

            const domain = [0.0, 1.0];

            let svg = d3.select(`#${this.mapName} svg`);
            if (svg.empty()) {
                svg = d3.select(`#${this.mapName}`)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", [0, 0, width + widthOffset, height])
                    .attr("style", "max-width: 100%; height: 90%;");
            } else {
                svg.selectAll("g").remove(); // Remove existing map elements
            }
            
            const country = this.country;
            var path = d3.geoPath();
            
            const g = svg.append("g");
            
            var tooltip = d3.select(`#${this.mapName}`).select("#map-tooltip")
                .attr("class", "maptip")
                .attr("state", "None")
                .attr("percent", "None")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("z-index", 100)
                .style("text-align", "left");

            const maptipOffset = 5;
            function moveMapTooltip() {
                var coords = d3.mouse(document.getElementById("chart-container"));
                var xPos = coords[0] - 230; // - tooltip.node().getBoundingClientRect().width - maptipOffset;
                var yPos = coords[1] + maptipOffset + 50;
                tooltip
                    .style("left", xPos + "px")
                    .style("top", yPos + "px")
                    .style("visibility", "hidden");
            }

            let highlightedPath = null;
            let currentStateData = null;
            let stateSpend = {};

            function updateTooltipContent() {
                tooltip.html(tooltipContentTemplate
                    .replace("{stateName}", currentStateData.name)
                    .replace("{statePercentage}", (currentStateData.value * 100).toFixed(4))
                    .replace("{costRange}", `${currencySymbol + (stateSpend.lower_bound < 1 ? '0' : d3.format('.4s')(stateSpend.lower_bound))} - ${currencySymbol + (stateSpend.upper_bound < 1 ? '0' : d3.format('.4s')(stateSpend.upper_bound))}`)
                );
            }

            this.fetchTopoData().then(mapDataset => {

                function handleMouseOver(id) {
                    tooltip.style("visibility", "visible");
                    if (currentStateData === null) {
                        currentStateData = _d.find(item => item.stateId === id);
                        stateSpend = {
                            lower_bound: currentStateData.minSpend,
                            upper_bound: currentStateData.maxSpend,
                        };
                    }
                    updateTooltipContent();
                    highlightedPath = g.append("path")
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 2)
                        .attr("stroke-linejoin", "round")
                        .attr("d", path(topojson.mesh(mapDataset, topo_data, (a, b) => a.id === id || b.id === id)))
                        .attr("pointer-events", "none");
                    moveMapTooltip();
                }

                function handleMouseMove(id) {
                    if (currentStateData === null) {
                        currentStateData = _d.find(item => item.stateId === id);
                        stateSpend = {
                            lower_bound: currentStateData.minSpend,
                            upper_bound: currentStateData.maxSpend,
                        };
                    }
                    updateTooltipContent();
                    moveMapTooltip();
                    tooltip.style("visibility", "visible");
                }

                function handleMouseOut() {
                    tooltip.style("visibility", "hidden");
                    currentStateData = null;
                    if (highlightedPath) {
                        highlightedPath.remove();
                        highlightedPath = null;
                    }
                }

                d3.select('#map_loader').style('display', 'none');
                
                var topo_data = null;
                if (country === 'us') { // Or old germany
                    topo_data = mapDataset.objects.states;
                } else if (country === 'es') {
                    for (let i = 70; i <= 79; i++) { // Move canary islands closer to mainland
                        mapDataset.arcs[i][0][0] += 2400;
                        mapDataset.arcs[i][0][1] += 4300;
                    }
                    topo_data = mapDataset.objects.autonomous_regions;
                } else if (country === 'dk') {
                    mapDataset.arcs[19][0][0] -= 2000; // Move danish isle closer to mainland
                    topo_data = mapDataset.objects.default;
                } else {
                    topo_data = mapDataset.objects.default;
                }

                var filteredData = topojson.feature(mapDataset, topo_data).features;

                const states = g.append("g")
                    .attr("cursor", "pointer")
                    .selectAll("path")
                    .data(topojson.feature(mapDataset, topo_data).features)
                    .enter().append("path")
                    .attr("d", path)
                    .attr("class", "county")
                    .attr("data-fips", d => { return d.id })
                    .attr("fill", d => {
                        const stateData = _d.find(item => item.stateId === d.id);
                        return customColorInterpolator(stateData ? Number(stateData.value).toFixed(20) : 0);
                    })
                    .on("mouseover", function(e,d) {
                        const hoveredData = d3.select(this).data()[0]; // Get the data associated with the hovered element
                        if (country === 'es' && (hoveredData.id === '04' || hoveredData.id === '05')) { return; }
                        handleMouseOver(hoveredData.id);
                    })
                    .on("mousemove", function(e,d) {
                        const hoveredData = d3.select(this).data()[0];
                        if (country === 'es' && (hoveredData.id === '04' || hoveredData.id === '05')) { return; }
                        handleMouseMove(hoveredData.id)
                    })
                    .on("mouseout", handleMouseOut);
                   
                // Add a square box pointing to a territory that might be too difficult to highlight with the mouse
                // const width = 970;
                // const height = 610;
                const smallTerritoryBoxes = [
                    {
                        country: 'ca',
                        id: 'CA.PE',
                        name: 'P.E.I.',
                        squareSize: 40,
                        squareX: 820,
                        squareY: 560,
                        lineXOffset: 0,
                        lineYOffset: 10,
                        lineXEnd: 755,
                        lineYEnd: 545,
                    },
                    {
                        country: 'au',
                        id: 'AU.ACT',
                        name: 'A.C.T.',
                        squareSize: 50,
                        squareX: 780,
                        squareY: 500,
                        lineXOffset: 1,
                        lineYOffset: 1,
                        lineXEnd: 690,
                        lineYEnd: 455,
                    },
                    {
                        country: 'br',
                        id: 'BR.DF',
                        name: 'D.F.',
                        squareSize: 50,
                        squareX: 740,
                        squareY: 495,
                        lineXOffset: 1,
                        lineYOffset: 1,
                        lineXEnd: 583,
                        lineYEnd: 335,
                    },
                    {
                        country: 'de',
                        id: 'DE.BE',
                        name: 'Berlin',
                        squareSize: 60,
                        squareX: 764,
                        squareY: 170,
                        lineXOffset: 1,
                        lineYOffset: 25,
                        lineXEnd: 649,
                        lineYEnd: 195,
                    },
                    {
                        country: 'de',
                        id: 'DE.HH',
                        name: 'Hamburg',
                        squareSize: 60,
                        squareX: 150,
                        squareY: 20,
                        lineXOffset: 60,
                        lineYOffset: 30,
                        lineXEnd: 435,
                        lineYEnd: 110,
                    }
                    ,
                    {
                        country: 'de',
                        id: 'DE.HB',
                        name: 'Bremen',
                        squareSize: 60,
                        squareX: 100,
                        squareY: 160,
                        lineXOffset: 60,
                        lineYOffset: 30,
                        lineXEnd: 379,
                        lineYEnd: 146,
                    }
                ]

                function createSmallTerritoryBox(box) {
                    if (box.country !== country) {
                        return;
                    }

                    // const squareX = width - box.squareSize - box.squareX; // Position it at the top right
                    // const squareY = height - box.squareSize - box.squareYOffset;
                    const lineXStart = box.squareX + box.lineXOffset;
                    const lineYStart = box.squareY + box.lineYOffset;
                    const lineData = [
                        [lineXStart, lineYStart],
                        [box.lineXEnd, box.lineYEnd]
                    ];

                    g.append("path")
                        .attr("d", path({ type: "LineString", coordinates: lineData }))
                        .attr("stroke", "black")
                        .attr("stroke-width", 1);
                        
                    const territorySquare = g.append("rect")
                        .attr("x", box.squareX)
                        .attr("y", box.squareY)
                        .attr("width", box.squareSize)
                        .attr("height", box.squareSize)
                        .attr("stroke", outlineColor)
                        .attr("rx", 5) // Adjust the radius for rounded corners as needed
                        .attr("ry", 5) // Adjust the radius for rounded corners as needed
                        .attr("data-fips", d => { return box.id })
                        .attr("fill", d => {
                            const stateData = _d.find((item) => item.stateId === box.id);
                            return customColorInterpolator(stateData ? Number(stateData.value).toFixed(20) : 0);
                        }); // Set the square's fill color
                    
                    territorySquare
                        .on("mouseover", function(e,d) {
                            if (country === 'es' && (box.id === '04' || box.id === '05')) { return; }
                            d3.select(this).attr("stroke", "black").attr("stroke-width", 2);
                            handleMouseOver(box.id);
                        })
                        .on("mousemove", function(e,d) {
                            if (country === 'es' && (box.id === '04' || box.id === '05')) { return; }
                            handleMouseMove(box.id);
                        })
                        .on("mouseout", function() {
                            d3.select(this).attr("stroke", outlineColor);
                            handleMouseOut();
                        });
                    
                    // Add the territory label so user will know what territory the box is pointing to
                    g.append("text")
                        .attr("x", box.squareX + box.squareSize / 2)
                        .attr("y", box.squareY + box.squareSize + 15) // Adjust the vertical position as needed
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .text(box.name);
                }
                        
                smallTerritoryBoxes.forEach(box => {
                    createSmallTerritoryBox(box);
                });
                
                // Add invisible square to smaller regions (islands) to make it easier to highlight them
                const boxes = [
                    {
                        country: 'es',
                        id: '05',
                        x: 20,
                        y: height - 150,
                        width: 340,
                        height: 150,
                        transform: "" 
                    },
                    {
                        country: 'es',
                        id: '04',
                        x: 770,
                        y: 240,
                        width: 200,
                        height: 80,
                        transform: "rotate(-38 " + (770 + 200 / 2) + " " + (240 + 80 / 2) + ")"
                    }
                ]

                function createInvisibleSquare(box) {
                    if (box.country !== country) {
                        return;
                    }
                    const islandSquare = g.append("rect")
                        .attr("x", box.x)
                        .attr("y", box.y)
                        .attr("width", box.width)
                        .attr("height", box.height)
                        .attr("fill", "none")
                        .attr("stroke", "none")
                        .attr("pointer-events", "all")
                        .attr("transform", box.transform)
                        .attr("data-fips", d => { return box.id })
                        .on("mouseover", function(e, d) { handleMouseOver(box.id); })
                        .on("mousemove", function(e, d) { handleMouseMove(box.id); })
                        .on("mouseout", function() { handleMouseOut(); });
                }

                boxes.forEach(box => {
                    createInvisibleSquare(box);
                });

                // Create visual dividng lines for Spain
                if (country === 'es') {
                    // Draw a divider
                    const topLine = [
                        [20, height - 150],
                        [360, height - 150]
                    ];
                    const sideLine = [
                        [360, height - 150],
                        [360, height]
                    ];
                    g.append("path")
                        .attr("d", path({ type: "LineString", coordinates: topLine }))
                        .attr("stroke", "black")
                        .attr("stroke-width", 1);
                    g.append("path")
                        .attr("d", path({ type: "LineString", coordinates: sideLine }))
                        .attr("stroke", "black")
                        .attr("stroke-width", 1);
                }

                // Create box line for Denmark island
                if (country === 'dk') {
                    const squareCoordinates = [
                        [705, 470], // Top-left corner
                        [790, 470], // Top-right corner
                        [790, 555], // Bottom-right corner
                        [705, 555], // Bottom-left corner
                        [705, 470], // Close the path by returning to the starting point
                    ];

                    // Create an SVG path element for the square
                    g.append("path")
                        .attr("d", d3.line()(squareCoordinates)) // Use d3.line() to create the path data
                        .attr("stroke", "black")
                        .attr("stroke-width", 1)
                        .attr("fill", "none"); // Set the fill to "none" to make it an outline
                }

                g.append("path")
                    .attr("fill", "none")
                    .attr("stroke", outlineColor)
                    .attr("stroke-width", 1.5)
                    .attr("stroke-linejoin", "round")
                    .attr("pointer-events", "none")
                    .attr("d", function(a, b) {
                        return path(topojson.mesh(mapDataset, topo_data, (a, b) => true));
                    });
                

                var mapTextTip = $("#map-textip");
                let unknownStateData = _d.find(item => item.name === "Unknown");
                mapTextTip
                    .html(`
                        This module shows where in the country ads by this funder/FB page were shown for the selected timeframe.
                        <br><br>
                        Hover over any part of the map to see what percentage of the ads' audience came from that state/region for the selected timeframe.
                        <br><br>
                    ` +
                    (unknownStateData ? `<span style="color: yellow;">NOTE:<br>* Out of the audience exposed to this funder's ads, an average of <u>${(unknownStateData.value * 100).toFixed(2)}%</u> came from regions that were either unidentified or located outside the selected country. This visualization takes into account the data from these unknown/outside regions.
                        <br>
                        * The estimated total ad spending by this funder (in regions outside the selected country or in unknown regions) during the specified timeframe is between: ${currencySymbol + (unknownStateData.minSpend < 1 ? '0' : d3.format('.4s')(unknownStateData.minSpend))} and ${currencySymbol + (unknownStateData.maxSpend < 1 ? '0' : d3.format('.4s')(unknownStateData.maxSpend))}.</span>
                        </span>` : "" )
                    
                    );
                
                // Make tooltip smoother (tooltip won't freeze if the user hovers over it)
                tooltip
                    .on("mouseover", function() {
                        moveMapTooltip();
                        tooltip
                            .style("visibility", "hidden");
                    })
                    .on("mousemove", function() {
                        moveMapTooltip();
                        tooltip
                            .style("visibility", "hidden");
                    })

                d3.select(`#${this.mapName}`)
                    .style("visibility", "visible")
                    .style("display", "flex");

            });

            ////////////////////////////////////////
            // -- FINISHED PROCESSING MAP DATA -- //
            // ---- BEGIN LEGEND GENERATION! ---- //
            
            const margin = 40;
            const yOffset = 300;
            const xOffset = 30;

            const gradientScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, 1]);

            const grad = svg.append('defs')
            .append('linearGradient')
            .attr('id', 'grad')
            .attr('x1', '0%')
            .attr('x2', '0%')
            .attr('y1', '0%')
            .attr('y2', '100%');

            grad.selectAll('stop')
            .data([0, 0.1, 0.25, 1]) // Add 0.1 and 0.25 to the data array
            .enter()
            .append('stop')
            .attr('offset', d => 100 * gradientScale(d) + '%')
            .style('stop-color', d => customColorInterpolator(1 - d));

            // Checking if the rect element exists, and either append it or change its visibility
            let rect = svg.select('rect');
            if (rect.empty()) {
            rect = svg.append('rect')
                .attr('x', width - xOffset)
                .attr('y', margin + yOffset)
                .attr('width', widthOffset - 10)
                .attr('height', height / 2 - 2 * margin)
                .style('outline-style', 'solid')
                .style('outline-color', 'black')
                .style('outline-width', '2px')
                .style('fill', 'url(#grad)');
            } 

            // Checking if the text elements exist, and either append them or change their visibility
            let text0 = svg.select('.text0');
            let text10 = svg.select('.text10'); // Added text10
            let text25 = svg.select('.text25'); // Added text25
            let text100 = svg.select('.text100');
            let legendTitle = svg.select('.legendTitle');

            if (text0.empty()) {
                text0 = svg.append('text')
                    .attr('x', width + 2 - xOffset)
                    .attr('y', height / 2 - margin + 20 + yOffset)
                    .text('0%')
                    .style('font-size', '20px')
                    .attr('text-anchor', 'start')
                    .attr('class', 'text0');
            }

            if (text10.empty()) {
                text10 = svg.append('text')
                    .attr('x', width - 30 - xOffset) // Adjust the x-coordinate for 25%
                    .attr('y', height / 2 + yOffset / 2)
                    .text('10% -')
                    .style('font-size', '20px')
                    .attr('text-anchor', 'middle') // Center align the text
                    .attr('class', 'text10');
            }

            if (text25.empty()) {
                text25 = svg.append('text')
                    .attr('x', width - 30 - xOffset) // Adjust the x-coordinate for 25%
                    .attr('y', height / 2 + yOffset / 3)
                    .text('25% -')
                    .style('font-size', '20px')
                    .attr('text-anchor', 'middle') // Center align the text
                    .attr('class', 'text25');
            }

            if (text100.empty()) {
                text100 = svg.append('text')
                    .attr('x', width - 8 - xOffset)
                    .attr('y', margin - 5 + yOffset)
                    .text('100%')
                    .attr('text-anchor', 'start')
                    .style('font-size', '20px')
                    .attr('class', 'text100');
            }

            if (legendTitle.empty()) {
                legendTitle = svg.append('text')
                    .attr("transform", "rotate(90)")
                    .attr('x', margin + yOffset + 40)
                    .attr('y', -width + xOffset - 45)
                    .text('Log Scale')
                    .attr('text-anchor', 'start')
                    .style('font-size', '25px')
                    .attr('class', 'legendTitle')
            }

		}

	}
</script>