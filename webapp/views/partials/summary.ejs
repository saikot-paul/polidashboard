<div class="widget-container boxed">

	<div class="inner" id="summary">
		<div class="facebook_nav_light p-tip">
			<span class="facebook_date">
			</span>
			<div class="tiptext">
				Click to edit time frame
			</div>
		</div>
		<div id="summary-home">
			<h3 class="widget-title" id="top_10_title">
				About the Module
			</h3>
			<p>
				<a href="https://polidashboard.com/" target="_blank">PoliDashboard</a> is a data visualization tool designed to help voters, journalists, and campaign staffers to monitor the health of political discussions online and learn about the political and social issue ads that are being shown to users on Facebook and its various other products including Instagram. The data is automatically updated every four hours via the <a href="https://www.facebook.com/ads/library/api" target="_blank">Facebook Ad API</a>.
			</p>
			<p>
				<img src="/images/SML_logo_2012_transparent_black_text.png" style="max-height: 4em; width: auto; float: left; padding-right: 10px;">
				The dashboard is developed by the <a href="https://socialmedialab.ca/" target="_blank">Social Media Lab</a> at Ted Rogers School of Management in Toronto as part of an international election transparency initiative. Country-specific modules are presented in partnership with various academic and civic partners in countries where the <a href="https://www.facebook.com/ads/library/?active_status=all&ad_type=political_and_issue_ads&country=CA&media_type=all" target="_blank">Facebook Ad Library</a> is available.
			</p>
		</div>
		<div id="summary-focus">
			<!-- ### Start of Pages Funded Widget -->
			<h3 class="widget-title">
				Facebook Pages Funded by
				<div class="tip">
					<img src="/images/info.png">
					<div class="tiptext">
						This module shows Facebook Pages controlled by a funding entity. Funding entities on Facebook can set up and control multiple Facebook pages. Having a Facebook page is a prerequisite for running Custom Audiences and Lookalike Audiences advertisements on Facebook.
					</div>
				</div>
			</h3>
			<div class="navigation-instructions" id="right-navigation-instructions">
				<button class="exit-button" onclick="d3.select('#right-navigation-instructions').remove()"><i class="fas fa-times"></i></button>
				<strong>Navigation Instructions</strong>
				<ul>
					<li>Click on <i class="fas fa-chart-bar"></i> to see a chart of the total number of active ads per day posted by a page controlled by a funder.</li>
					<li>Hover over any dots in the line chart to see the total number of active ads by a funder (or a page that they control) on a specific date in the selected timeframe.</li>
				</ul>
			</div>
			
			<h4 id="pages_subtitle" class="summary_subtitle advertiser_name"></h4>
			<h4 id="pages_subtitle" class="summary_subtitle page_name"></h4>
			<div class="loader red" id="funder_pages_loader">
				<div class="lds-grid">
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
				</div>
			</div>
			<div id="funder_pages"></div>
			
			<!-- ### Start of Map Widget ### -->
			<% if (country === 'us') { %>
				<h3 class="widget-title" id="page-scroll">
					Where These Ads Were Shown
					<div class="tip">
						<img src="/images/info.png">
						<div class="tiptext">
							This module shows the distribution of this funder's viewed ads across different States.
							<br><br>
							Hover over any State to see what percentage of this funder's ads were shown there.
							<br><br>
							Ads for which no regional data is available are omitted.
						</div>
					</div>
				</h3>
					<h4 id="pages_subtitle" class="summary_subtitle advertiser_name"></h4>
				<!-- Map loader icon -->
				<h4 id="pages_subtitle" class="summary_subtitle page_name"></h4>
				<div class="loader red" id="map_loader">
					<div class="lds-grid">
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					</div>
				</div>
				<div class="widget-content" id="chart-container">
					<div id="map-tooltip"></div>
				</div>
			<% } %>

			
			<!-- ### Start of Ads Per Day Widget ### -->
			<h3 class="widget-title" id="page-scroll">
				Total Number of Active Ads Per Day
				<div class="tip">
					<img src="/images/info.png">
					<div class="tiptext">
						This chart shows the total number of ads that were active for each day of the selected timeframe.
					</div>
				</div>
			</h3>

			<h4 id="pages_subtitle" class="summary_subtitle advertiser_name"></h4>
			<h4 id="pages_subtitle" class="summary_subtitle page_name"></h4>
			<div class="loader red" id="timeline_loader">
				<div class="lds-grid">
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
				</div>
			</div>
			<div id="timeline">
			</div>

			<!-- ### Start of Demographic Widget ### -->
			<h3 class="widget-title">
				Who Was Shown These Ads
				<div class="tip">
					<img src="/images/info.png">
					<div class="tiptext">
						This module shows the age and gender breakdowns of people who saw ads by this funding entity - each dot represents one ad.
						<br><br>
						Hover over a dot to see that ad's distribution across all demographics, and click to see that ad's summary (ad will open in a new tab).
					</div>
				</div>
			</h3>

			<h4 id="pages_subtitle" class="summary_subtitle advertiser_name"></h4>
			<h4 id="pages_subtitle" class="summary_subtitle page_name"></h4>

			<div class="navigation-instructions" id="right-navigation-instructions">
				<button class="exit-button" onclick="d3.select('#right-navigation-instructions').remove()"><i class="fas fa-times"></i></button>
				<strong>Navigation Instructions</strong>
				<ul>
					<li>Hover and keep your mouse over a dot to see that ad's distribution across all demographic’s groups on Facebook.</li>
					<li>If all other dots (other than the dot you hovered over) is at or close to the 0% mark on the x-axis, it suggests that ad was only (or mostly) targeted at that specific demographic group and no other.</li>
					<li>Click on a dot see the ad and additional stats about the ad (ad will open in a new tab).</li>
					<li>New to box plot? Here’s a <a href="https://socialmedialab.ca/2021/09/03/improving-on-the-facebook-ad-library/" target="_blank">primer</a> on how to interpret a box plot chart.</li>
					<li>Note: if more than 1000 ads are visible, they will be hidden and replaced with a violin plot to save resources. Select a shorter time frame or use the page filters to see individual ads.</li>
				</ul>
			</div>

			<div id="demographics_legend">
				<span id="demographics_men">Men</span>
				<span id="demographics_women">Women</span>
				<span id="demographics_other">Unknown</span>
			</div>
			<div class="loader red" id="demographics_loader">
				<div class="lds-grid">
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
				</div>
			</div>
			<div id="demographics">

			</div>

			<!-- ### Start of Location Graph Widget ### -->
			<% if (country != 'us') { %>
				<h3 class="widget-title">
					Where These Ads Were Shown
					<div class="tip">
						<img src="/images/info.png">
						<div class="tiptext">
								This module shows the regions where people who saw ads by this funder are located - each point represents one ad.
								<br><br>
								Hover over a dot to see that ad's distribution across all regions, and click to see that ad's summary (ad will open in a new tab).
								<br><br>
								Ads for which no regional data is available are omitted
						</div>
					</div>
				</h3>
				<h4 id="pages_subtitle" class="summary_subtitle advertiser_name"></h4>
				<h4 id="pages_subtitle" class="summary_subtitle page_name"></h4>
				<div class="loader red" id="regions_loader">
					<div class="lds-grid">
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					</div>
				</div>
				<div id="regions">
				</div>
			<% } %>

		</div>
	</div>
</div>

<script type="text/javascript">
	const ALL = '.*?'
	const desktopMapWidth = 1
	let initial = true

	showAbout()
	function showAbout() {
		// Switch to 'about' view
		d3.select('#summary-home').style('display', 'block')
		d3.select('#summary-focus').style('display', 'none')
		d3.select('#summary-navigation-instructions').style('display', 'none')
		d3.select('#top_pages_loader').style('display', 'block')
	}

	var timelineData;
	var demographicsData;
	var chosenPage = null;

	let activeDemographicsRequest = null;
	let activFunderPagesRequest = null;
	let activeRequests = [];

	function performRequest(url, requestData, successCallback) {
		activeRequests.filter(req => req.url === url).forEach(req => req.request.abort());

		const request = $.post(url, requestData)
			.done(data => successCallback(data))
			.always(() => { activeRequests = activeRequests.filter(req => req !== request) });
		activeRequests.push({ url, request });
	}

	function performFunderRequests(funder) {
		const commonData = {
			startDay: fbStartDay,
			endDay: fbEndDay,
			funder,
			country
		};

		performRequest('/facebook_ads_v2/funder_demographics', commonData, demographicsData => {
			const filteredDemographics = pageFilter(demographicsData);
			drawDemographics(filteredDemographics);
			if (country !== 'us') {
				drawRegions(filteredDemographics);
			}
		});

		// Get the funder's pages
		performRequest('/facebook_ads_v2/funder_pages', commonData, pagesData => {
			d3.select('#funder_pages_loader').style('display', 'none');
			drawPages(pagesData, '#funder_pages');
		});

		// Get the funder's timeline
		performRequest('/facebook_ads_v2/funder_timeline', commonData, data => {
			timelineData = data;
			drawTimeline(data)
		});

		if (country === 'us') {
			performRequest('/facebook_ads_v2/funder_map', commonData, data => {
				// console.log(data);
				drawMap(data);
			});
		}
	}
	
	function showFunder(funder) {
		// Show statistics on a funding entity

		chosenPage = null;
		d3.selectAll('.page_name')
			.style('display', 'none')
			.html('')

		d3.select("#chart-container").style("visibility", "hidden")
		d3.select('#summary-home').style('display', 'none')
		d3.select('#summary-focus').style('display', 'block')
		d3.select('#summary-navigation-instructions').style('display', 'inline-block')
		d3.select('#demographics').html('')
		d3.select('#regions').html('')
		d3.select('#timeline').html('')
		d3.selectAll('.advertiser_name')
			.text('Funded by: ' + funder)
		d3.select('#funder_pages_loader').style('display', 'block')
		d3.select('#demographics_loader').style('display', 'block')
		d3.select('#timeline_loader').style('display', 'block')
		d3.select('#map_loader').style('display', 'block')
		if (country != 'us') d3.select('#regions_loader').style('display', 'block')
		d3.select('#funder_pages').html('')
		d3.select('#funder_note').remove()
		d3.select('.page_name')
			.style('display', 'none')
			.html('')

		// Scroll to the funder, if mobile
		if (isMobile) {
			$([document.documentElement, document.body]).animate({
				scrollTop: $("#summary").offset().top
			}, 500);
		}

		// Fix for Conservative Party naming discrepancy
		if (funder == 'Conservative Party of Canada - Parti conservateur du Canada') {
			d3.select('#summary').append('p')
				.attr('id', 'funder_note')
				.text('Note: While the other major parties use their full English and French titles when funding both their official party page and their leader\'s page, the Conservative party sometimes uses only the English title for these ads. These two variations have been combined here to allow comparison between the parties.')
		}

		// Handle null funder
		if (funder == 'No funding entity given') {
			funder = null;
		}

		performFunderRequests(funder);
	}

	function showPage(p) {
		// Highlight statistics on a specific page

		d3.select('#demographics_loader').style('display', 'block')
		d3.select('#demographics').html('')
		d3.select('#timeline_loader').style('display', 'block')
		d3.select('#map_loader').style('display', 'block')
		d3.select('#timeline').html('')
		if (country != 'us') {
			d3.select('#regions_loader').style('display', 'block')
			d3.select('#regions').html('')
		}
		// Scroll to show data if on mobile
		$([document.documentElement, document.body]).animate({
			scrollTop: $("#page-scroll").offset().top
		}, 500);

		chosenPage = p.page_id
		setTimeout(() => {
			// Add the "Posted by" subtitles
			d3.selectAll('.page_name')
				.style('display', 'block')
				.text(`Posted by: "${p.page_name}" Page`)
				.append('button')
				.attr('class', 'page_exit_button')
				.html('<i class="fas fa-times-circle"></i>')
				.on('click', revertPage)

			// Draw the three charts
			drawTimeline(pageFilter(timelineData))
			drawDemographics(pageFilter(demographicsData))
			if (country != 'us') drawRegions(pageFilter(demographicsData))
		}, 10)

	}

	function revertPage() {
		// Remove a selected page and redraw charts
		chosenPage = null;
		d3.selectAll('.page_name')
			.style('display', 'none')
			.html('')
		drawTimeline(pageFilter(timelineData))
		drawDemographics(pageFilter(demographicsData))
		if (country != 'us')  drawRegions(pageFilter(demographicsData))
	}

	function pageFilter(d) {
		// Remove all the results from a funder's data that don't match the current page (stored in global chosenPage)
		if (chosenPage == null) return d;
		else return d.filter(x => {
			return x.page_id == chosenPage
		})
	}

	function spendToText(spend) {
		// Format spend range
		return `${currencySymbol + d3.format('.4s')(spend.lower_bound)} - ${currencySymbol + d3.format('.4s')(spend.upper_bound)} Spent`
	}

	function impressionsToText(impressions) {
		// Format impression minimum
		return `More than ${d3.format('.4s')(impressions.lower_bound)} Impressions`
	}

	function perturb(y, amount) {
		// Add a random amount - used to stagger the scatter plot's y-axis
		return y + (Math.random() - 0.5)*amount
	}

	function getDemographicLabel(demographic) {
		// Format demographic for scatter plots
		if (demographic.gender=='female') return ('W ' + demographic.age)
		if (demographic.gender=='male') return ('M ' + demographic.age)
		return '? 18-65+'
	}

	// List of regions is given by server from countries.json
	var regionCodes = <%- JSON.stringify(regions) %>
	function getRegionLabel(id) {
		code = regionCodes[id.region]
		if (code == undefined) {
			console.log("Region not found (adding to 'other'):")
			console.log(id.region)
			return 'Other'
		}
		return code
	}

	const ageRanges = [
		'13-17',
		'18-24',
		'25-34',
		'35-44',
		'45-54',
		'55-64',
		'65+'
	]

	const ageLowerBounds = [
		13,
		18,
		25,
		35,
		45,
		55,
		65
	]

	function getAgeIndex(lowerBound) {
		// Get corresponding integer from age range (lower bound)
		for (i in ageLowerBounds) {
			if (ageLowerBounds[i] == lowerBound) return i
		}
	}

	function funderToFbUrl (funder) {
		// Format funding entity URL for Facebook
		return `https://www.facebook.com/ads/library/?active_status=active&ad_type=all&country=CA&q=${ encodeURIComponent(funder) }`
	}

	function demographicsCheckBoxId (plainText) {
		return 'demographics-checkbox-' + plainText.replace(/\s/g, '')
	}

	function drawPages(data, anchor) {
		// Draw the list of a funder's pages

		// Create the container for the page widget
		var pageContainers = d3.select(anchor)
			.html("")
			.selectAll('pageContainers')
			.data(data)
			.enter()
			.append('div')
				.attr('class', 'page-container')

		// Create the left column (with the filter button)
		var pageLefts = pageContainers.append('div')
			.attr('class', 'page-left')
			.append('button')
				.html('<i class="fas fa-chart-bar"></i>')
				.attr('class', 'page-filter-button')
				.on('click', d => {
					showPage(d)
				})

		// Create the right column with all the data
		var pageRights = pageContainers.append('div')
			.attr('class', 'page-right')

		// Create the page's name and link
		pageRights.append('p')
			.text(function (d) {
				if (data.length > 1) return (data.indexOf(d) + 1) + '. '
				else return ''
			})
			.append('a')
			.attr('href', function(d) {return (`https://www.facebook.com/${d.page_id}`)})
			.attr('target', '_blank')
			.text(function(d) {return d.page_name})

		// Create the number of ads
		pageRights.append('p')
			.text(function(d){return `${d.total_ads} Unique Ads `})
			.append('a')
				.attr('href', function(d) {return `https://www.facebook.com/ads/library/?active_status=all&ad_type=political_and_issue_ads&country=CA&view_all_page_id=${d.page_id}&sort_data[direction]=desc&sort_data[mode]=relevancy_monthly_grouped&search_type=keyword_unordered&media_type=all`})
				.attr('target', '_blank')
				.html('<ion-icon name="search"></ion-icon>')

		// Create the spend range and tooltip explanation
		pageRights.append('p')
			.text(function(d){return spendToText(d.spend)})
			.attr('class', 'p-tip')
			.append('div')
				.attr('class', 'tiptext')
				.html('Facebook reports ad spending as a range with a maximum and minimum. These values are the sum of these maxima and minima for all ads by the page.')

		// Create the number of impressions range and tooltip explanation
		pageRights.append('p')
			.text(function(d) {return impressionsToText(d.impressions)})
			.attr('class', 'p-tip')
			.append('div')
			.attr('class', 'tiptext')
			.html('Facebook reports ad impressions as a range with a maximum and minimum. This value is the minimum possible number of impressions based on this data for all ads by the page.')
	}

	updateFacebookTimestamps()
	function updateFacebookTimestamps() {
		end = new Date()
		end.setDate(end.getDate() - fbEndDay)
		startDay = new Date()
		startDay.setDate(startDay.getDate() - fbStartDay)
		format = d3.timeFormat('%b %d')

		d3.selectAll('.facebook_date')
			.html(`Time Frame: ${format(startDay)} - ${format(end)}`)
		d3.selectAll('.facebook_timestamp_no_calendar')
			.html(`${format(startDay)} - ${format(end)}`)
	}

	function drawTimeline(data, pageId=null) {
		// Draw the funder's ad timeline
		d3.select('#timeline_loader').style('display', 'none')

		// Get the start and end dates
		var end = new Date()
		end.setDate(end.getDate() - fbEndDay)
		var start = new Date()
		start.setDate(start.getDate() - fbStartDay)

		var rows = [
			['date'],
			['0 - 99'],
			['100 - 499'],
			['500 - 999'],
			['1000 - 4999'],
			['5000+']
		]

		// Create empty rows
		for (var day = new Date(start.getTime()); day <= end; day.setDate(day.getDate() + 1)) {
			rows[0].push(new Date(day.getTime()))
			for (var r = 1; r < rows.length; r++) {
				rows[r].push(0)
			}
		}

		// Fill rows based on data
		data.forEach(ad => {
			var row = rows.map(el => el[0]).indexOf(rangeToLabel(ad.spend))
			for (var c = 1; c < rows[0].length; c++) {
				if (rows[0][c] > Date.parse(ad.first_collected) && rows[0][c] < Date.parse(ad.latest_collected)) {
					rows[row][c]++;
				}
			}
		})

		// Generate chart with C3.js
		var chart = c3.generate({
			data: {
				x: 'date',
				columns: rows,
				// type: 'timeseries',
				// groups: [group],
				// order: order
			},
			axis: {
				x: {
					type: 'timeseries',
					tick: {
						format: '%Y-%m-%d',
						culling: true
					},
					padding: {
						right: 0,
						left: 0
					}
				},
				y: {
					tick: {
						count: 4,
						format: d3.format('d')
					},
					min: 0,
					padding: {
						bottom: 0
					}
				}
			},
			bindto: '#timeline',
			size: {
				height: '200'
			},
			padding: {
				right: 25
			}
		});
	}

	function drawDemographics(data) {
		// Create the targetted demographics chart

		// Clear existing chart if there is one
		var container = d3.select("#demographics")
		container.html("")

		// Get the chart dimensions
		var margin = {top: 10, right: 30, bottom: 30, left: 50}
		var width = container.node().getBoundingClientRect().width - margin.left - margin.right
		var height = 400 - margin.top - margin.bottom

		// Create the drawing space
		var svg = container
			.append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
			.append("g")
				.attr("transform",
					"translate(" + margin.left + "," + margin.top + ")");

		// Create x axis
		var x = d3.scaleLinear()
			.domain([0, 1])
			.range([ 0, width ]);
		svg.append("g")
			.attr("transform", "translate(0," + height + ")")
			.call(
				d3.axisBottom(x)
					.tickFormat(d3.format('.0%'))
			);



		var yDomain = ['M 13-17', 'W 13-17', 'M 18-24', 'W 18-24', 'M 25-34', 'W 25-34', 'M 35-44', 'W 35-44', 'M 45-54', 'W 45-54', 'M 55-64', 'W 55-64', 'M 65+', 'W 65+', '? 18-65+', '']

		// Used to determine the color of the dots
		var color = function(d) {
			if (d.demographic[0] == 'M') return colorSchemes.blue
			if (d.demographic[0] == 'W') return colorSchemes.green
			return '#F0A202'
		}

		// Clean the data for use in the chart
		var cleanedData = [] // The cleaned data will be a list of objects corresponding to each dot
		var foundUnderage = false // Most of the time we only show engagement for users 18+,
		// but sometimes there is underage engagement that needs to be shown.
		for (var i = 0; i < data.length; i++) {
			var foundDemos = []

			for (var j = 0; j < data[i].demographics.length; j++) {
				var point = data[i].demographics[j]
				var demo = getDemographicLabel(point._id)

				if (yDomain.includes(demo)) {
					cleanedData.push({
						demographic: demo,
						percentage: point.percentage,
						ad: data[i]._id,
						url: `https://www.facebook.com/ads/library/?id=${data[i]._id}`,
						spend: rangeToLabel(data[i].spend)
					})

					foundDemos.push(demo)

					if (demo.includes('13')) {
						foundUnderage = true
					}
				} else {
					console.log("NOT IN DOMAIN")
					console.log(point)
				}
			}

			for (var j = 0; j < yDomain.length-1; j++) {
				if (!foundDemos.includes(yDomain[j])) {
					cleanedData.push({
						demographic: yDomain[j],
						percentage: 0,
						ad: data[i]._id,
						url: `https://www.facebook.com/ads/library/?id=${data[i]._id}`,
						spend: rangeToLabel(data[i].spend)
					})
				}
			}
		}

		// Remove the underage demographics if they are all zero
		if (!foundUnderage) {
			yDomain.splice(0, 2)
			cleanedData = cleanedData.filter(d => {return yDomain.includes(d.demographic)})
		}

		// Calculate y-coordinates of each row
		var yRange = []
		for (var i = 0; i < yDomain.length; i++) {
			yRange.push(height * i / (yDomain.length - 1))
		}

		// Create y-axis
		var y = d3.scaleOrdinal()
			.domain(yDomain)
			.range(yRange)
		svg.append("g")
			.call(d3.axisLeft(y));

		var defaultRadius = 3

		// Function to be called when you mouseover a dot
		var highlight = function(d) {
			d3.selectAll('.ad_'+d.ad)
				.transition()
				.duration(200)
				.attr('r', 6)
				.style('opacity', 1)
				.style('fill', "black")
		}

		// Function to be called when you mouse out of a dot
		var doNotHighlight = function(d) {
			d3.selectAll('.demo_dot')
				.transition()
				.duration(200)
				.attr('r', defaultRadius)
				.style('opacity', 0.2)
				.style('fill', color)
		}

		// Function to be called when you click a dot
		var viewAd = function(d) {
			window.open(d.url, '_blank')
		}

		// console.log(cleanedData)
		if (data.length < 1000) {
			// Draw and style each of the dots
			svg.append('g')
				.selectAll('dot')
				.data(cleanedData)
				.enter()
				.append('circle')
					.attr('class', function (d) {return 'demo_dot ad_' + d.ad})
					.attr('cx', function(d) {return x(d.percentage)})
					.attr('cy', function(d) {return perturb(y(d.demographic), 12)})
					.attr('r', defaultRadius)
					.style('fill', color)
					.style('opacity', 0.2)
					.style('cursor', 'pointer')
					.on("mouseover", highlight)
					.on("mouseleave", doNotHighlight)
					.on("click", viewAd)
		} else {
			// If there are too many dots, show a violin plot instead of dots

			// Create a histogram of x-axis frequencies
			var histogram = d3.histogram()
				.domain([0, 1])
				.thresholds(x.ticks(160))
				.value(d => d)

			// Create the nested statistics
			var numstat = d3.nest()
				.key(function(d) { return d.demographic;})
				.rollup(function(d) {   // For each key..
					input = d.map(function(g) { return g.percentage;})
					bins = histogram(input)   // And compute the binning on it.
					var lengths = bins.map(b => b.length)
					var maxLength = d3.max(lengths)
					return lengths.map((v, i) => {
						return {
							size: v / maxLength,
							start: i / lengths.length
						}
					})
				})
				.entries(cleanedData)

			// Draw the violins
			svg
				.selectAll("myViolin")
				.data(numstat)
				.enter()        // So now we are working group per group
				.append("g")
				.attr("transform", function(d){ return("translate(0, " + y(d.key) +")") } ) // Translation on the right to be at the group position
				.append("path")
					.style("fill", function(d) {
						if (d.key[0] == 'M') return colorSchemes.blue
						if (d.key[0] == 'W') return colorSchemes.green
						return '#F0A202'
					})
					.datum(function(d){ return(d.value)})
					.attr("d", d3.area()
						.y0(function(d){return(d.size * 10)} )
						.y1(function(d){return(-d.size * 10) } )
						.x(function(d){return(x(d.start)) } )
						   // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
					)

		}
		// boxplot height
		var boxHeight = 12

		// Calculate quartiles and median for each row
		var sumstat = d3.nest()
			.key(function(d) {return d.demographic})
			.rollup(function(d) {
				q1 = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.25)
				median = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.5)
				q3 = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.75)
				interQuantileRange = q3 - q1
				min = q1 - 1.5 * interQuantileRange
				max = q3 + 1.5 * interQuantileRange
				return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max})
			})
			.entries(cleanedData)

		// Draw the horizontal lines ("whiskers")
		svg.selectAll('horizLines')
			.data(sumstat)
			.enter()
			.append('line')
				.attr("y1", function(d){return y(d.key)})
				.attr("y2", function(d){return y(d.key)})
				.attr("x1", function(d){return x(d.value.min)})
				.attr("x1", function(d){return x(d.value.max)})
				.attr('stroke', 'black')

		// Draw the boxes
		svg.selectAll('boxes')
			.data(sumstat)
			.enter()
			.append('rect')
				.attr('y', function(d){return(y(d.key) - boxHeight/2)})
				.attr('x', function(d){return(x(d.value.q1))})
				.attr('width', function(d){return(x(d.value.q3) - x(d.value.q1))})
				.attr('height', boxHeight)
				.attr('stroke', 'black')
				.attr('fill', 'transparent')
				.style('pointer-events', 'none')

		// Draw the media lines
		svg.selectAll('medianLines')
			.data(sumstat)
			.enter()
			.append('line')
				.attr('x1', function(d){return(x(d.value.median))})
				.attr('x2', function(d){return(x(d.value.median))})
				.attr('y1', function(d){return(y(d.key) - boxHeight/2)})
				.attr('y2', function(d){return(y(d.key) + boxHeight/2)})
				.attr('stroke', 'black')


		// Remove the loading indicator once the chart is finished
		d3.select('#demographics_loader').style('display', 'none')
	}

	function drawRegions(data) {

		// Remove loading indicator
		d3.select('#regions_loader').style('display', 'none')

		// Clear the region chart if one exists
		var container = d3.select("#regions")
		container.html("")
		var margin = {top: 10, right: 30, bottom: 30, left: 50}
		var width = container.node().getBoundingClientRect().width - margin.left - margin.right
		var height = Object.keys(regionCodes).length * 30 + 50

		// Create the drawing area
		var svg = container
			.append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
			.append("g")
				.attr("transform",
					"translate(" + margin.left + "," + margin.top + ")");

		// Create the x-axis
		var x = d3.scaleLinear()
			.domain([0, 1])
			.range([ 0, width ]);
		svg.append("g")
			.attr("transform", "translate(0," + height + ")")
			.call(
				d3.axisBottom(x)
					.tickFormat(d3.format('.0%'))
			);

		// Get the y-domain from list of regions
		var yDomain = Object.values(regionCodes)
		yDomain.push('Other')
		yDomain.push('')

		// Used to pick the color of the dots
		var color = function(d) {
			return colorSchemes.red
		}

		// Create a list of objects (one corresponding to each dot)
		var cleanedData = []
		for (var i = 0; i < data.length; i++) {
			var foundRegions = []

			for (var j = 0; j < data[i].regions.length; j++) {
				var point = data[i].regions[j]
				var region = getRegionLabel(point._id)

				cleanedData.push({
					region: region,
					percentage: point.percentage,
					ad: data[i]._id,
					url: `https://www.facebook.com/ads/library/?id=${data[i]._id}`,
					spend: rangeToLabel(data[i].spend)
				})

				foundRegions.push(region)
			}

			if (data[i].regions.length != 0) {
				for (var j = 0; j < yDomain.length-1; j++) {
					if (!foundRegions.includes(yDomain[j])) {
						cleanedData.push({
							region: yDomain[j],
							percentage: 0,
							ad: data[i]._id,
							url: `https://www.facebook.com/ads/library/?id=${data[i]._id}`,
							spend: rangeToLabel(data[i].spend)
						})
					}
				}
			}
		}

		// Get quartiles and media for box plots
		var sumstat = d3.nest()
			.key(function(d) {return d.region})
			.rollup(function(d) {
				q1 = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.25)
				median = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.5)
				q3 = d3.quantile(d.map(function(g) { return g.percentage;}).sort(d3.ascending),.75)
				interQuantileRange = q3 - q1
				min = Math.max(q1 - 1.5 * interQuantileRange, 0)
				max = Math.min(q3 + 1.5 * interQuantileRange, 1)
				return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max})
			})
			.entries(cleanedData)
			.sort((a, b) => d3.descending(a.value.median, b.value.median))

		// Sort y-domain (regions) by their prevalence
		yDomain = yDomain.sort((a, b) => {
			var arr = sumstat.map(d => d.key)
			return d3.ascending(
				(arr.indexOf(a) == -1) ? 100000 : arr.indexOf(a),
				(arr.indexOf(b) == -1) ? 100000 : arr.indexOf(b)
			)
		})

		// Calculate y-coordinates of each row
		var yRange = []
		for (var i = 0; i < yDomain.length; i++) {
			yRange.push(height * i / (yDomain.length - 1))
		}

		// Create y-axis
		var y = d3.scaleOrdinal()
			.domain(yDomain)
			.range(yRange)
		svg.append("g")
			.call(d3.axisLeft(y));

		var defaultRadius = 3

		// Used when dots are moused over
		var highlight = function(d) {
			d3.selectAll('.ad_region_'+d.ad)
				.transition()
				.duration(200)
				.attr('r', 6)
				.style('opacity', 1)
				.style('fill', 'black')
		}

		// Removes highlights when mouse leaves
		var doNotHighlight = function(d) {
			d3.selectAll('.region_dot')
				.transition()
				.duration(200)
				.attr('r', defaultRadius)
				.style('opacity', 0.2)
				.style('fill', color)
		}

		// Opens the ad's page on facebook (on click)
		var viewAd = function(d) {
			window.open(d.url, '_blank')
		}


		if (data.length < 1000) {
			// Draw the dots
			svg.append('g')
				.selectAll('dot')
				.data(cleanedData)
				.enter()
				.append('circle')
					.attr('class', function (d) {return 'region_dot ad_region_' + d.ad})
					.attr('cx', function(d) {return x(d.percentage)})
					.attr('cy', function(d) {return perturb(y(d.region), 12)})
					.attr('r', defaultRadius)
					.style('fill', color)
					.style('opacity', 0.2)
					.style('cursor', 'pointer')
					.on("mouseover", highlight)
					.on("mouseleave", doNotHighlight)
					.on("click", viewAd)
		} else {
			// If there are more than 1000 ads, use a violin plot instead of dots

			// Create histogram for violin plot
			var histogram = d3.histogram()
				.domain([0, 1])
				.thresholds(x.ticks(160))
				.value(d => d)

			// Calculate statistics for each bin on the histogram
			var numstat = d3.nest()
				.key(function(d) { return d.region;})
				.rollup(function(d) {   // For each key..
					input = d.map(function(g) { return g.percentage;})
					bins = histogram(input)   // And compute the binning on it.
					var lengths = bins.map(b => b.length)
					var maxLength = d3.max(lengths)
					return lengths.map((v, i) => {
						return {
							size: v / maxLength,
							start: i / lengths.length
						}
					})
				})
				.entries(cleanedData)

			// Draw the violins
			svg.selectAll("myViolin")
				.data(numstat)
				.enter()
				.append("g")
				.attr("transform", function(d){ return("translate(0, " + y(d.key) +")") } )
				.append("path")
					.style("fill", color)
					.datum(function(d){ return(d.value)})
					.attr("d", d3.area()
						.y0(function(d){return(d.size * 10)} )
						.y1(function(d){return(-d.size * 10) } )
						.x(function(d){return(x(d.start)) } )
					)

		}

		var boxHeight = 12
		// Draw the horizontal lines ('whiskers') of the boxplots
		svg.selectAll('horizLines')
			.data(sumstat)
			.enter()
			.append('line')
				.attr("y1", function(d){return y(d.key)})
				.attr("y2", function(d){return y(d.key)})
				.attr("x1", function(d){return x(d.value.min)})
				.attr("x1", function(d){return x(d.value.max)})
				.attr('stroke', 'black')
				.style('pointer-events', 'none')

		// Draw the rectangles of the boxplots
		svg.selectAll('boxes')
			.data(sumstat)
			.enter()
			.append('rect')
				.attr('y', function(d){return(y(d.key) - boxHeight/2)})
				.attr('x', function(d){return(x(d.value.q1))})
				.attr('width', function(d){return(x(d.value.q3) - x(d.value.q1))})
				.attr('height', boxHeight)
				.attr('stroke', 'black')
				.attr('fill', 'transparent')
				.style('pointer-events', 'none')

		// Draw the media lines of the box plot
		svg.selectAll('medianLines')
			.data(sumstat)
			.enter()
			.append('line')
				.attr('x1', function(d){return(x(d.value.median))})
				.attr('x2', function(d){return(x(d.value.median))})
				.attr('y1', function(d){return(y(d.key) - boxHeight/2)})
				.attr('y2', function(d){return(y(d.key) + boxHeight/2)})
				.attr('stroke', 'black')
				.style('pointer-events', 'none')

	}

	async function fetchTopoData() {
		try {
			const mapDataset = await d3.json("https://d3js.org/us-10m.v1.json");
			return mapDataset;
		} catch (error) {
			console.error("Error fetching map data:", error);
			throw error;
		}
	}

	function drawMap(data) {
		const width = 970;
		const height = 610;
		const outlineColor = "#CCCCCC";

		const customColorInterpolator = t => {
			const r = Math.round(255 * t); // Gradually increase red channel
			const g = 0; // No green component
			const b = 0; // No blue component
			return `rgb(${r}, ${g}, ${b})`;
		};
		
		const domain = [0.0, 1.0];
		const colorScale = d3.scaleLinear()
			.domain(domain)
			.interpolate(d3.interpolateRgb)
			.range(['white', '#FF2222'])


		let svg = d3.select("#chart-container svg");
		if (svg.empty()) {
			svg = d3.select("#chart-container")
				.append("svg")
				.attr("width", width)
				.attr("height", height)
				.attr("viewBox", [0, 0, width, height])
				.attr("style", "max-width: 90%; height: 90%;");
		} else {
			svg.selectAll("g").remove(); // Remove existing map elements
		}

		const path = d3.geoPath();
		const g = svg.append("g");
		
		var tooltip = d3.select("#chart-container").select("#map-tooltip")
			.attr("class", "maptip")
			.attr("state", "None")
			.attr("percent", "None")
			.style("position", "absolute")
			.style("visibility", "hidden")

		const maptipOffset = 5;
		function moveMapTooltip() {
			var coords = d3.mouse(document.getElementById("summary"));
			var xPos = coords[0] - tooltip.node().getBoundingClientRect().width - maptipOffset;
			var yPos = coords[1] + maptipOffset;
			tooltip
				.style("left", xPos + "px")
				.style("top", yPos + "px")
				.style("visibility", "hidden");
		}

		let highlightedPath = null;
		let currentStateData = null;

		fetchTopoData().then(mapDataset => {
			d3.select('#map_loader').style('display', 'none')
			const states = g.append("g")
				.attr("cursor", "pointer")
				.selectAll("path")
				.data(topojson.feature(mapDataset, mapDataset.objects.states).features)
				.enter().append("path")
				.attr("d", path)
				.attr("class", "county")
				.attr("data-fips", d => { return d.id })
				.attr("fill", d => {
					const stateData = data.find(item => item.stateId === d.id);
					return colorScale(stateData ? Number(stateData.value).toFixed(20) : 0);
				})
				.on("mouseover", function(e,d) {
					const hoveredData = d3.select(this).data()[0]; // Get the data associated with the hovered element
					tooltip.style("visibility", "visible");

					// Highlight the state/country
					highlightedPath = g.append("path")
						.attr("fill", "none")
						.attr("stroke", "black")
						.attr("stroke-width", 2)
						.attr("stroke-linejoin", "round")
						.attr("d", path(topojson.mesh(mapDataset, mapDataset.objects.states, (a, b) => a.id === hoveredData.id || b.id === hoveredData.id)));
				})
				.on("mousemove", function(e,d) {
					if (currentStateData === null) {
						const hoveredData = d3.select(this).data()[0];
						currentStateData = data.find(item => item.stateId === hoveredData.id);
					}
					tooltip.html(
						"<span class='tooltip-emoji' style='top: 1px; position: absolute; right: 3px;'>◥</span>" + // Unicode character for ◥
						"<div class='maptip-title'>Ad Distribution</div>" +
						"<hr style='margin-top: 0; margin-bottom: 10px'>" +
						"<div class='maptip-content'>" +
						"<p style='margin-bottom: 0'><span class='maptip-label'>State:</span> " + currentStateData.name + "</p>" +
						"<p style='margin-bottom: 0; color: yellow;'><span class='maptip-label'>Ads Shown:</span> " + (currentStateData.value * 100).toFixed(4) + "%</p>" +
						"</div>"
					);

					// Update tooltip position
					moveMapTooltip();
					tooltip
						.style("visibility", "visible");
				})
				.on("mouseout", function() {
					tooltip.style("visibility", "hidden");
					currentStateData = null;
					if (highlightedPath) {
						highlightedPath.remove();
						highlightedPath = null; // Reset the reference
					}
				});

			g.append("path")
				.attr("fill", "none")
				.attr("stroke", outlineColor)
				.attr("stroke-width", 1.5)
				.attr("stroke-linejoin", "round")
				.attr("d", path(topojson.mesh(mapDataset, mapDataset.objects.states, (a, b) => true)));
			
			// Make tooltip smoother (tooltip won't freeze if the user hovers over it)
			tooltip
				.on("mouseover", function() {
					moveMapTooltip();
					tooltip
						.style("visibility", "hidden");
				})
				.on("mousemove", function() {
					moveMapTooltip();
					tooltip
						.style("visibility", "hidden");
				})

			d3.select("#chart-container")
				.style("visibility", "visible")
		});
	}

</script>

